# Mini OS 学習カリキュラム - 12 日間で OS 開発をマスターしよう 🚀

## 📖 Software Engineer 向け解説

**このプロジェクトが特別な理由:**

通常のアプリケーション開発では、OS（Linux、Windows、macOS）が提供する API を使ってプログラムを書きます。しかし、このプロジェクトでは**OS そのものを作る**ことで、コンピュータがどのように動作するかを根本から理解できます。

**なぜ OS 開発を学ぶべきか:**

-   **システムの動作原理理解**: メモリ管理、プロセス切り替え、I/O 処理の仕組み
-   **パフォーマンス最適化**: ボトルネックの原因と対策の深い理解
-   **デバッグスキル向上**: 低レベルの知識により複雑な問題の解決力向上
-   **アーキテクチャ理解**: CPU、メモリ、I/O デバイスの連携メカニズム

## 🖥️ PC Architecture Basics (ソフトウェアエンジニア向け)

### x86 プロセッサアーキテクチャとは

**x86**: Intel 8086 から始まるプロセッサファミリー。現在の Intel/AMD プロセッサの基盤。

-   **16-bit 時代**: 8086, 8088 (1978 年) - MS-DOS の時代
-   **32-bit 時代**: 80386 (1985 年) - Windows 95/Linux 登場
-   **64-bit 時代**: x86_64 (2003 年) - 現代の PC/サーバー

このプロジェクトは 32-bit x86 をターゲットにしています。

### CPU 動作モード

**Real Mode (リアルモード)**:

-   16-bit 環境、最大 1MB メモリ
-   BIOS が動作するモード
-   セグメント:オフセット形式のアドレッシング
-   現代でも電源投入時は最初にこのモードで起動

**Protected Mode (プロテクトモード)**:

-   32-bit 環境、最大 4GB メモリ
-   メモリ保護機能により安全な実行環境
-   現代 OS の基盤となるモード
-   GDT (Global Descriptor Table)によるセグメント管理

### ハードウェアコンポーネント

**PIC (Programmable Interrupt Controller) - 8259A**:

-   外部デバイス（キーボード、タイマー等）からの割り込み信号を CPU に伝達
-   IRQ0-7 (マスター), IRQ8-15 (スレーブ) の 16 本の割り込みライン
-   OS では通常、BIOS 設定(IRQ0-15)から 32-47 番に再マップして使用

**PIT (Programmable Interval Timer) - 8254**:

-   定期的なタイマー割り込みを生成（OS のスケジューリングに必要）
-   基準クロック 1.193182MHz を分周して任意の周期を生成
-   チャンネル 0 がシステムタイマーとして使用される

**VGA (Video Graphics Array)**:

-   テキストモード: 80x25 文字、各文字は色属性付き
-   フレームバッファ: 0xB8000 番地からの直接メモリアクセス
-   文字+属性のペア（2 バイト）で画面制御

**PS/2 キーボード**:

-   シリアル通信でスキャンコードを送信
-   IRQ1 割り込みによる非同期入力処理
-   ポート 0x60(データ), 0x64(ステータス)でアクセス

## 💾 Floppy Disk Structure (フロッピーディスク構造)

この OS は 1.44MB フロッピーディスクイメージとして作成されます。

### Physical Structure (物理構造)

```
フロッピーディスク断面図:
        ┌────────────────────────────┐
        │           Track 0          │ Track 0 (外周)
        │ ┌───────────────────────┐  │
        │ │         Track 1       │  │ Track 1
        │ │  ┌─────────────────┐  │  │
        │ │  │      Track 2    │  │  │ Track 2
        │ │  │      Track 3    │  │  │ Track 3
        │ │  │       ...       │  │  │  ...
        │ │  │      Track 79   │  │  │ Track 79（内周）
        │ │  │                 │  │  │
        │ │  └─────────────────┘  │  │
        │ └───────────────────────┘  │
        └────────────────────────────┘

トラック（本当は円形）1つ分を横に伸ばしてみると:
  ┌──────────┬───┬───┬┬┬┬┬┬┬────┐
  │ Sector 1 | 2 | 3 | ... | 18 |
  └──────────┴───┴───┴┴┴┴┴┴┴────┘

Track = 同心円状のデータトラック (0-79)
Sector = トラック上の扇形区画 (1-18)
```

### Logical Structure (論理構造)

```
1.44MB Floppy Disk Layout:

総容量: 1,474,560 bytes (1440KB)
├─ Tracks: 80 (0-79)
├─ Heads: 2 (表面・裏面)
├─ Sectors per Track: 18 (1-18)
└─ Bytes per Sector: 512

計算: 80 tracks × 2 heads × 18 sectors × 512 bytes = 1,474,560 bytes

Sector番号の計算:
Physical Sector = (Track × 2 + Head) × 18 + (Sector - 1)

例: Track 0, Head 0, Sector 1 = 0 (Boot Sector)
例: Track 0, Head 0, Sector 2 = 1 (Kernel開始位置)
```

### Boot Sector Layout (ブートセクタ配置)

```
Sector 0 (First 512 bytes):
┌─────────────────┬───────────────────────────────────────────┐
│ Offset          │ Contents                                  │
├─────────────────├───────────────────────────────────────────┤
│ 0x000 - 0x1FD   │ Boot Code (510 bytes)                     │
│                 │ ├─ A20 Line Enable                        │
│                 │ ├─ GDT (Global Descriptor Table) Setup    │
│                 │ ├─ Load Kernel from Sector 1+             │
│                 │ └─ Switch to Protected Mode               │
├─────────────────├───────────────────────────────────────────┤
│ 0x1FE - 0x1FF   │ Boot Signature (0x55AA)                   │
└─────────────────┴───────────────────────────────────────────┘

Sectors 1+ (Kernel):
┌─────────────────┬───────────────────────────────────────────┐
│ Sectors 1-N     │ Kernel Binary (Variable Size)             │
│                 │ ├─ kernel_entry.s (Assembly entry point)  │
│                 │ ├─ interrupt.s (Interrupt handlers)       │
│                 │ ├─ context_switch.s (Thread switching)    │
│                 │ └─ kernel.c (Main kernel code)            │
├─────────────────├───────────────────────────────────────────┤
│ Sectors N+1-2879│ Unused Space (Padded with zeros)          │
│ (End of disk)   │ Total: 1440KB = 2880 sectors              │
└─────────────────┴───────────────────────────────────────────┘
```

### Memory Layout After Boot (ブート後のメモリ配置)

```
Physical Memory Layout (32-bit Protected Mode):

0x00000000 ┌─────────────────────────────────────┐
           │ Interrupt Vector Table (IVT)        │
0x00000400 ├─────────────────────────────────────┤
           │ BIOS Data Area                      │
0x00000500 ├─────────────────────────────────────┤
           │ Free Conventional Memory            │
0x00007C00 ├─────────────────────────────────────┤
           │ Boot Sector (Loaded by BIOS)        │ ← 512 bytes
0x00007E00 ├─────────────────────────────────────┤
           │ Free Memory                         │
0x000A0000 ├─────────────────────────────────────┤
           │ VGA Memory                          │
0x000B8000 │ ├─ Text Mode Buffer                 │ ← VGA text display
0x000C0000 ├─────────────────────────────────────┤
           │ BIOS ROM                            │
0x00100000 ├─────────────────────────────────────┤ ← 1MB boundary
           │ Kernel Code (Loaded here)           │ ← Our OS kernel
0x00200000 ├─────────────────────────────────────┤ ← 2MB
           │ Kernel Stack                        │ ← Stack grows down
0x00300000 ├─────────────────────────────────────┤
           │ Thread Stacks & Data                │
           │ Available RAM...                    │
0xFFFFFFFF └─────────────────────────────────────┘
```

## 概要

このリポジトリは、基本的な PC ブート概念から本格的なマルチスレッドオペレーティングシステムまでを 12 日間で段階的に学習するための教育用カリキュラムです。各日は前の概念を基に、実践的な開発で知識を積み上げていきます。

C 言語の知識は前提とし、x86 アセンブリは初心者にも分かりやすく説明します。各段階で実際に動作する OS を作りながら、コンピュータサイエンスの核心概念を体験的に学びます。

最終完成版は[day99_completed](day99_completed)です。

## 前提知識・環境

### 必要な前提知識

**C 言語 (中級レベル)**:

-   ポインタ、構造体、配列の理解
-   関数ポインタとコールバックの概念
-   メモリレイアウト（スタック、ヒープ）の理解
-   ビット演算とヘキサデシマル表記

**コンピュータサイエンス基礎 (推奨)**:

-   データ構造（リスト、キュー、スタック）
-   アルゴリズムの基本概念
-   16 進数の読み書き
-   バイナリ形式の理解

**x86 アセンブリ (学習しながら習得)**:

-   このカリキュラムで段階的に説明
-   最初は理解不要、コピー&ペーストから始める

### 開発環境セットアップ

**macOS の場合:**

```bash
# Homebrewでツールをインストール
brew install i686-elf-gcc nasm qemu clang-format
```

**Linux (Ubuntu/Debian) の場合:**

```bash
# クロスコンパイラとアセンブラ
sudo apt-get update
sudo apt-get install build-essential nasm qemu-system-i386 clang-format

# download i686-elf-tools-linux.zip
# from https://github.com/lordmilko/i686-elf-tools/releases/
wget https://github.com/lordmilko/i686-elf-tools/releases/download/13.2.0/i686-elf-tools-linux.zip
# extract it in /usr/local
cd /usr/local
sudo unzip ~/Downloads/i686-elf-tools-linux.zip
```

**Windows の場合:**

1. **WSL2 (推奨)**: Ubuntu on Windows で上記 Linux 手順を実行
2. **MSYS2**: Windows ネイティブ環境での開発
3. **VMware/VirtualBox**: Linux 仮想マシンを使用

**必要なツール:**

-   `i686-elf-gcc`: 32-bit x86 クロスコンパイラ
-   `nasm`: x86 アセンブラ
-   `qemu-system-i386`: x86 エミュレータ
-   `make`: ビルド自動化ツール

## 🚨 学習前の準備確認

### 必要な前提知識レベル

-   **C 言語**: 中級（ポインタ、構造体、配列の操作が理解できる）
-   **アセンブリ**: 初級（レジスタ、メモリ、基本命令の概念を知っている）
-   **Linux/Unix**: 基本操作（make、コンパイル、ターミナル操作ができる）

### よくある学習の躓きポイント

1. **Day 01-02**: ブートプロセスが複雑 → **解決策**: まず Day03 から始めて、慣れたら Day01 に戻る
2. **Day 04-05**: インラインアセンブリが難解 → **解決策**: サンプルコードを実行してから理解を深める
3. **Day 08-09**: コンテキストスイッチが理解困難 → **解決策**: デバッガで実際のレジスタ変化を観察する
4. **Day 10-11**: スケジューラが複雑 → **解決策**: 単純な 2 スレッドから始めて段階的に拡張する

### トラブル時の対処法

-   **ビルド失敗**: 開発環境セクションの手順を再確認
-   **QEMU で起動しない**: day99_completed ディレクトリで動作確認してから自分のコードと比較
-   **理解が困難**: 各 day の README.md の「理解度チェック」で知識を確認

## 🎯 学習ロードマップ

### Phase 1: 基礎編 (Day 01-04)

**目標**: ブートローダと C 言語カーネルの基本

| Day              | テーマ               | 主な学習内容                            | 成果物                     |
| ---------------- | -------------------- | --------------------------------------- | -------------------------- |
| [Day 01](day01/) | ブートローダ基礎     | BIOS、MBR、16-bit x86 アセンブリ        | "Hello World" ブートローダ |
| [Day 02](day02/) | プロテクトモード移行 | A20 ライン、GDT、32-bit 切替            | VGA テキスト表示           |
| [Day 03](day03/) | C 言語統合           | freestanding C、VGA API                 | C カーネル基盤             |
| [Day 04](day04/) | シリアルデバッグ     | UART、I/O ポート、インライン アセンブリ | デバッグ環境構築           |

### Phase 2: システム編 (Day 05-08)

**目標**: 割り込みシステムとマルチスレッドの基礎

| Day              | テーマ               | 主な学習内容                | 成果物               |
| ---------------- | -------------------- | --------------------------- | -------------------- |
| [Day 05](day05/) | 割り込みインフラ     | IDT、例外処理、ISR スタブ   | 例外ハンドラシステム |
| [Day 06](day06/) | タイマー割り込み     | PIC、PIT、IRQ0 ハンドリング | 100Hz タイマー動作   |
| [Day 07](day07/) | スレッドデータ構造   | TCB、READY リスト、状態管理 | マルチスレッド基盤   |
| [Day 08](day08/) | コンテキストスイッチ | レジスタ保存復元、ESP 切替  | スレッド切替機能     |

### Phase 3: 応用編 (Day 09-12)

**目標**: 実用的な OS の完成

| Day              | テーマ                           | 主な学習内容                   | 成果物           |
| ---------------- | -------------------------------- | ------------------------------ | ---------------- |
| [Day 09](day09/) | プリエンプティブスケジューリング | ラウンドロビン、タイムスライス | 自動スレッド切替 |
| [Day 10](day10/) | スリープ/タイミング              | ブロッキング、ウェイクアップ   | sleep()関数実装  |
| [Day 11](day11/) | キーボード入力システム           | PS/2、リングバッファ、IRQ1     | ユーザー入力処理 |
| [Day 12](day12/) | 統合と最終プロジェクト           | 品質向上、テスト、ドキュメント | 完成した OS      |

## 🚀 Quick Start

### 1. リポジトリクローンと環境確認

```bash
# リポジトリクローン
git clone <repository-url>
cd mini-os

# 開発ツール確認
make check-env
```

### 2. Day 01 から開始

```bash
cd day01
make clean
make all
make run  # QEMUでOSを起動
```

### 3. 各 Day の進め方

1. **README.md 読む**: その日の学習目標と理論を理解
2. **実装する**: 段階的にコードを作成
3. **テストする**: `make run`で動作確認
4. **理解する**: なぜそのコードが必要かを考察
5. **次に進む**: 完成版と比較して次の Day へ

## 📁 ディレクトリ構造

```
mini-os/
├── README.md                    # このファイル
├── day01/                       # Day 01: ブートローダ基礎
│   ├── README.md
│   ├── boot.s
│   └── Makefile
├── day01_completed/             # Day 01完成版（参考用）
├── day02/                       # Day 02: プロテクトモード
├── day02_completed/
...
├── day12/                       # Day 12: 最終統合
├── day12_completed/
└── day99_completed/             # 最終完成版（拡張機能付き）
    ├── src/
    │   ├── kernel/
    │   ├── drivers/
    │   ├── boot/
    │   └── include/
    ├── tests/
    └── docs/
```

## 🎓 学習のコツ

### 効果的な学習方法

**1. 段階的な理解**:

-   一度にすべてを理解しようとしない
-   動作することを確認してから詳細を学ぶ
-   疑問点はメモして後で調べる

**2. 手を動かす**:

-   コピー&ペーストでも最初は OK
-   動作を確認してから意味を理解
-   小さな変更を加えて実験

**3. デバッグスキル**:

-   シリアル出力を活用
-   QEMU モニターコマンドを覚える
-   システムハングに慣れる（正常な現象）

**4. 復習と応用**:

-   前の Day のコードを見返す
-   他のアーキテクチャとの比較
-   現代 OS との違いを考察

### つまづきやすいポイント

**アセンブリ言語**:

-   最初は暗記で OK、徐々に理解
-   レジスタ名とサイズ（AX, EAX 等）の区別
-   アドレッシングモード（直接、間接等）

**メモリレイアウト**:

-   物理アドレスと論理アドレス
-   セグメンテーションの概念
-   スタック成長方向（下向き）

**割り込み処理**:

-   同期（例外）と非同期（IRQ）の違い
-   割り込み無効化の必要性
-   EOI（End of Interrupt）の送信タイミング

## 🔧 トラブルシューティング

### よくある問題と解決法

**1. ビルドエラー**:

```bash
# ツールが見つからない
brew install i686-elf-gcc nasm qemu  # macOS
sudo apt-get install build-essential nasm qemu-system-i386  # Linux

# パスが通っていない
export PATH="/usr/local/bin:$PATH"
```

**2. QEMU 起動しない**:

```bash
# QEMUバイナリ確認
which qemu-system-i386

# 権限確認
ls -la os.img
```

**3. 画面が真っ黒**:

-   ブートシグネチャ（0x55AA）の確認
-   ジャンプ命令の飛び先アドレス
-   GDT 設定とセグメントセレクタ

**4. システムハング**:

-   無限ループの意図的な配置確認
-   割り込み設定の順序
-   スタックポインタの初期化

### デバッグ技術

**シリアル出力の活用**:

```bash
# シリアル出力をファイルに保存
make run > debug.log 2>&1

# リアルタイムでログ確認
make run | tee debug.log
```

**QEMU モニター**:

```bash
# デバッグモードで起動
make debug

# モニターコマンド（QEMUコンソール）
(qemu) info registers  # レジスタ状態
(qemu) info mem        # メモリマップ
(qemu) x/10i $eip      # 現在の命令を逆アセンブル
```

## 🤝 貢献とフィードバック

### 改善への参加

このプロジェクトは教育用途に最適化を目指しています：

**歓迎する貢献**:

-   誤字脱字、技術的間違いの修正
-   より分かりやすい説明の提案
-   追加のデバッグ情報やトラブルシューティング

**プルリクエストガイドライン**:

1. 変更内容を明確に説明
2. 既存の学習順序を維持
3. 初心者にとっての分かりやすさを最優先
4. テスト済みであることを明記

## 💪 学習モチベーション維持のコツ

### 段階的な達成感を大切に

-   **Day 01-02**: 「Hello World」が画面に出力 → ハードウェアを制御できた実感
-   **Day 03-04**: C 言語でカーネル構築 → 本格的な OS 開発の基盤完成
-   **Day 05-06**: 割り込みで心拍表示 → システムの「生きている」感覚
-   **Day 07-08**: スレッド切り替え成功 → マルチタスクの基本原理習得
-   **Day 09-10**: プリエンプティブスケジューリング → 現代 OS と同じ仕組み理解
-   **Day 11-12**: キーボード入力対応 → 実用的な OS への第一歩

### 挫折しそうになったら

1. **day99_completed を動かす**: 完成形を見てモチベーション回復
2. **一歩戻る**: 難しい Day は前の Day に戻って基礎を再確認
3. **コミュニティ**: 同じ境遇の仲間と学習進捗を共有
4. **キャリア視点**: この知識がどう仕事に活かせるかを想像

### 学習時間の目安

-   **初心者**: 各 Day 2-4 時間、全体で 40-60 時間
-   **中級者**: 各 Day 1-2 時間、全体で 15-30 時間
-   **上級者**: 各 Day 0.5-1 時間、全体で 8-15 時間

### 継続のための環境作り

-   **定期的な時間確保**: 週末に集中、または平日 30 分ずつ
-   **成果の可視化**: 各 Day の動作動画撮影やスクリーンショット保存
-   **学習ログ**: 理解したこと、躓いたポイントをメモ
-   **SNS 共有**: 学習進捗を Twitter 等で共有してモチベーション向上

## 🎉 完成後の Next Step

### さらなる学習

**このプロジェクト完成後に挑戦できる内容**:

**中級レベル**:

-   **Shell 作成**: コマンドラインシェルの作成
-   **64-bit 移行**: x86_64 アーキテクチャへの拡張
-   **メモリ管理**: ページング、仮想メモリ、MMU
-   **ファイルシステム**: FAT12/16、簡易ファイル操作
-   **ネットワーク**: 基本的な TCP/IP 実装

**上級レベル**:

-   **マルチコア対応**: SMP、CPU 間同期
-   **デバイスドライバ**: より多くのハードウェア対応
-   **ユーザーランド**: システムコール、プロセス分離
-   **GUI**: 基本的なウィンドウシステム

**他アーキテクチャ**:

-   **ARM**: Raspberry Pi 向け OS 開発
-   **RISC-V**: 新しいオープンアーキテクチャ
-   **組み込み**: マイコン向けリアルタイム OS

### キャリアへの活用

**このスキルが活かせる分野**:

-   **システムソフトウェア**: OS、デバイスドライバ、ファームウェア
-   **組み込みシステム**: IoT、自動車、産業機器
-   **高性能コンピューティング**: HPC、分散システム、データベース
-   **セキュリティ**: マルウェア解析、システム監査、脆弱性研究
-   **ゲーム開発**: エンジン最適化、低レベル性能調整

**面接でのアピールポイント**:

-   ハードウェア理解に基づく最適化能力
-   低レベルデバッグの実践経験
-   システム全体を俯瞰する設計力
-   困難な問題への粘り強い取り組み

---

## 📚 用語集 (Glossary)

### 序盤 (Day 01-03)

-   **ブートセクタ (Boot Sector) / MBR**: BIOS が最初に読み込む 512 バイトのデータ領域。ハードウェアの制約によりこのサイズが決まっており、BIOS がこれをメモリの 0x7C00 番地にロードして実行を開始する。OS 開発の入り口となる重要な領域。
-   **org 0x7c00**: アセンブラのディレクティブで、プログラムがメモリの 0x7C00 番地に配置されることを宣言。歴史的経緯として、CP/M-86 との互換性を保つためにこのアドレスが選ばれた。これはリアルモード時代のメモリマップに基づく。
-   **プロテクトモード**: リアルモードの対義語で、32 ビット/64 ビットの保護された実行環境。メモリ保護、仮想メモリ、特権レベルの概念を提供。リアルモードでは 1MB のメモリ制限があったが、プロテクトモードでは 4GB 以上のメモリを使用可能で、現代 OS の必須機能。
-   **VGA テキストバッファ / 0xB8000**: ビデオカードのメモリ領域に直接書き込むことで画面表示を実現する仕組み（メモリマップド I/O）。0xB8000 番地に文字コードと属性を 2 バイト単位で書き込むと、自動的に画面に表示される。ハードウェアとソフトウェアの橋渡しとなる重要な概念。
-   **リンカースクリプト (.ld)**: コンパイル後のオブジェクトファイルを最終的な実行ファイルに配置するための指示書。オブジェクトファイルのセクション（.text, .data 等）をメモリのどのアドレスに配置するかを制御。freestanding 環境での OS 開発では、メモリレイアウトを正確に定義する必要があるため重要。

### 中盤 (Day 04-08)

-   **割り込み (Interrupt)**: CPU に対する「イベント通知」の仕組み。ハードウェアやソフトウェアからの非同期要求に応答し、現在の処理を一時中断してハンドラを実行。OS の応答性を高める核となる概念。
-   **IRQ (Interrupt ReQuest)**: 割り込み要求信号が通る物理的な線（割り込み線）。PIC が複数の IRQ を管理し、CPU に伝達。IRQ 0-15 が標準的に割り当てられており、それぞれキーボード、タイマー等のデバイスに対応。
-   **PIC (Programmable Interrupt Controller)**: 8259A チップで、複数のデバイスからの IRQ を束ねて CPU に効率的に伝達。BIOS 設定では IRQ0-15 を 32-47 番に再マップして使用し、OS の割り込み管理を可能にする。
-   **PIT (Programmable Interval Timer)**: 8254 チップで、定期的に割り込みを発生させるタイマー装置。基準クロック 1.193182MHz を分周して任意の周期を生成。チャンネル 0 がシステムタイマーとして使用され、スケジューリングの基盤となる。
-   **I/O ポート (inb, outb)**: メモリ空間とは別のアドレス空間（I/O 空間）を使ってハードウェアと通信する仕組み。inb 命令でポートからデータ読み込み、outb で書き込み。ハードウェア制御の基本的な方法。
-   **コンテキストスイッチ**: マルチタスクの核となる概念。「あるスレッドの実行状態（レジスタ、スタックポインタ等）を保存し、別のスレッドの状態を復元する」処理。TCB を使って効率的に管理される。
-   **TCB (Thread Control Block)**: スレッドの状態を保存するためのデータ構造。レジスタ値、スタックポインタ、実行状態、優先度などの情報を含む。各スレッドに 1 つずつ割り当てられ、スケジューラがこれを操作。

### 終盤・全体

-   **特権レベル (Ring 0)**: CPU の保護機能の一部で、OS のカーネルが動作する最も特権の高いモード。Ring 0 では全てのハードウェアアクセスが可能で、Ring 3（ユーザーモード）では制限がかかる。OS のセキュリティ基盤。
-   **リングバッファ (SPSC)**: Single Producer Single Consumer の略で、「書き込み側と読み出し側が 1 つずつのシンプルな円環状バッファ」。衝突せずにデータを安全にやり取りできる。キーボード入力などの非同期通信に適しており、day99_completed で技術的に詳細に実装されている。
-   **ツールチェーン (i686-elf-gcc, nasm)**: クロスコンパイル環境のこと。通常の gcc ではホスト OS（macOS 等）用のコードを生成するが、i686-elf-gcc はターゲット OS（自作 OS）用のコードを生成する「クロスコンパイラ」。nasm はアセンブラで、両方とも OS 開発に不可欠。

---

**🎯 このカリキュラムで、あなたも OS 開発者の仲間入りです！**

質問、フィードバック、改善提案をお待ちしています。一緒により良い学習リソースを作り上げましょう！
