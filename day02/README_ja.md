# Day 02: プロテクトモード移行 ⚡

## 本日のゴール

16 ビットリアルモードから 32 ビットプロテクトモードへ安全に移行し、VGA テキストバッファに直接文字列を表示する。

## 背景

Day1 ではリアルモードで"Hello OS!"を表示しましたが、リアルモードにはメモリ制限（1MB）があり、現代 OS の開発には不十分です。本日はプロテクトモードへ移行することで 4GB のメモリ空間とメモリ保護機能を獲得し、本格的な OS 開発の基盤を築きます。

## 新しい概念

-   **プロテクトモード**: リアルモードの対義語で、32 ビットの保護された実行環境。メモリ保護と 4GB メモリ空間を提供し、現代 OS の必須機能。「何を」「何から」保護するのか：プログラム間のメモリを保護し、無効なアクセスを防ぐ。
-   **A20 ライン**: 8086 の設計バグによるアドレスラップアラウンドを修正するためのアドレス線。なぜ有効化が必要か：1MB 超のメモリを正しくアクセスするため。
-   **GDT (Global Descriptor Table)**: プロテクトモードでのメモリセグメントを定義するテーブル。アクセス権限とサイズを管理。
-   **CR0.PE**: CR0 レジスタの PE ビットで、プロテクトモードを有効化するスイッチ。
-   **VGA テキストバッファ / 0xB8000**: ビデオメモリに直接書き込むことで画面表示を実現。なぜこのアドレス：メモリマップド I/O 方式で、ハードウェアがこのアドレスを画面にマップしている。

### 学習内容

-   A20 ラインの有効化（1MB 超のアドレス空間の利用）
-   GDT（Global Descriptor Table）の構築
-   CR0.PE を立ててプロテクトモードに切り替え
-   Far jump で CS を更新して 32 ビットコードに遷移
-   VGA テキストバッファ（0xB8000）への直接出力

## タスクリスト

-   [ ] A20 ラインを有効化して 1MB 超のアドレス空間を利用可能にする
-   [ ] GDT（null/code/data セグメント）を構築してメモリ管理の基盤を作る
-   [ ] CR0.PE=1 を設定してプロテクトモードに移行する
-   [ ] far jump で CS を更新して 32 ビットコードへ遷移する
-   [ ] 32 ビット側でセグメントレジスタとスタックを設定する
-   [ ] VGA バッファ 0xB8000 に文字列を直接書き込んで画面表示する
-   [ ] QEMU で動作確認する

## 前提知識の確認

### 必要な知識

-   Day 01 の内容（リアルモード、BIOS、0x7C00）
-   16 進数と CPU レジスタの基礎

### 今日新しく学ぶこと

-   A20 ラインの役割（8086 互換の 20 ビットアドレスからの拡張）
-   GDT の構造（ディスクリプタ、アクセスバイト、グラニュラリティ）
-   CR0 レジスタとプロセッサモード切替
-   32 ビットコードでのセグメント設定とスタック初期化

## なぜプロテクトモードに移行する必要があるのか？

**リアルモード**は、1978 年の Intel 8086 プロセッサの動作モードです。現代でも互換性のために電源投入時はこのモードから始まります：

**リアルモードの限界:**

-   **16 ビット環境**: CPU が 16 ビット単位でしか処理できない（現代の 32/64 ビットと比較して低速）
-   **1MB メモリ制限**: アドレス空間が 1MB（0x00000〜0xFFFFF）しか使えない
-   **セグメント:オフセット**: `セグメント×16＋オフセット`という複雑なアドレス計算
-   **メモリ保護なし**: プログラムが他のプログラムのメモリを誤って書き換え可能

**プロテクトモードの利点:**

-   **32 ビット処理**: CPU の本来の性能を発揮（64 ビット CPU でも 32 ビットモードは高速）
-   **4GB メモリ空間**: 現代アプリケーションに十分なメモリ（32 ビット=2³²=4,294,967,296 バイト）
-   **メモリ保護**: GDT（後述）によりプログラム間の安全な分離
-   **現代 OS 基盤**: Linux、Windows 等のマルチタスク OS の基礎技術

## A20 ラインとは何で、なぜ有効化する必要があるのか？

**A20 ライン**は、コンピュータの歴史的な互換性問題から生まれた概念です。

**歴史的背景:**

-   **8086 CPU (1978 年)**: 20 本のアドレス線（A0-A19）で 1MB（2²⁰=1,048,576 バイト）をアドレス
-   **16 ビットレジスタの制限**: セグメント:オフセットで最大 1,048,575 バイト + 15 バイト = 1,048,590 バイト
-   **ラップアラウンド問題**: 1MB 境界を超えるアドレスが 0 番地に戻る（0x100000 → 0x00000）

**80286 以降の問題:**

-   **24 本のアドレス線**: A20-A23 が追加され 16MB までアドレス可能
-   **互換性の問題**: 古いソフトがラップアラウンドに依存している
-   **A20 ゲート**: 20 番目のアドレス線を無効化して 8086 をエミュレート

**現代の OS 開発での対処:**

-   **A20 有効化**: Fast A20 方式（ポート 0x92）で素早く有効化
-   **プロテクトモード必須**: 32 ビットアドレス空間を正しく使うために必要
-   **互換性維持**: BIOS は起動時に A20 を無効状態で開始

**A20 ラインの背景:**

-   8086 CPU の設計バグで、1MB 以上のアドレス（例: 0x100000）が 0 番地に戻る「ラップアラウンド」が発生
-   A20 (Address line 20) を有効化することで、このバグを修正し、フルアドレス空間を利用可能に
-   無効のままプロテクトモードに入ると、メモリアクセスが破綻し、OS が正常動作しない

## GDT（Global Descriptor Table）の役割

**GDT**は、プロテクトモードでのメモリ管理の中核となるデータ構造です。

**リアルモードとの違い:**

-   **リアルモード**: セグメント値 ×16 ＋オフセットの単純計算
-   **プロテクトモード**: セグメントレジスタが GDT のインデックスを指す

**GDT エントリの構成（8 バイト）:**

-   **ベースアドレス（32bit）**: セグメントの開始位置
-   **リミット（20bit）**: セグメントのサイズ（4KB 単位で最大 4GB）
-   **アクセス権（8bit）**: 実行可/読み書き可/特権レベル等
-   **フラグ（4bit）**: 32bit/16bit、粒度等の属性

**基本的な GDT 構成:**

1. **NULL ディスクリプタ（エントリ 0）**: 無効アクセスを検出するダミー
2. **CODE セグメント（0x08）**: 実行可能コード領域
3. **DATA セグメント（0x10）**: データ/スタック領域

**現代 OS との関係:**

-   **Linux**: 最小限の GDT ＋ページング中心
-   **Windows**: より複雑なセグメント＋ページング
-   **このプロジェクト**: フラットメモリモデル（全セグメントが 0-4GB）

**GDT とは:**

-   セグメントの属性（ベースアドレス、サイズ、アクセス権限）を定義するテーブル
-   プロテクトモードでは、CS/DS などのセグメントレジスタが GDT のエントリを指すようになる
-   これにより、メモリ領域を保護・分離できる

**なぜ必要:**

-   リアルモードのセグメント（単なる 16 倍）から、柔軟なメモリ管理へ移行
-   null ディスクリプタ（エントリ 0）は無効アクセスを防ぐためのダミー

## プロテクトモード移行の流れ

```
リアルモード初期化 → A20有効化 → GDT登録(lgdt) → CR0.PE=1 → far jump → 32ビット初期化 → VGA出力
```

1. Fast A20（I/O ポート 0x92）で A20 を素早く有効化
2. GDT（null/code/data）を定義し、`lgdt`で CPU に登録
3. `CR0.PE=1`でプロテクトモードを有効化
4. far jump で CS をロードし、32 ビットコードへ入る（32 ビットオフセットで実行）
5. 32 ビット側でセグメントレジスタとスタックを設定し、VGA へ文字列出力

【メモ】最小構成の GDT とセグメント

-   GDT はまず null/code/data の 3 本を用意（null は番兵）。
-   CS=0x08、DS=ES=FS=GS=SS=0x10 に設定する“儀式”を覚えれば OK（詳細フラグは定型で十分）。

## 実践: 2 ファイル構成

### ステップ 1: プロジェクト構造

```
day02/
├── README.md   # このファイル
├── boot.s      # 16bit→32bit切替とVGA表示, GDT定義
└── Makefile    # ビルドと実行
```

完成版は `day02_completed/` を参照してください。

### ステップ 2: boot.s の作成

`boot.s` では A20→GDT→CR0→far jump→VGA の順で進みます。

```assembly
; boot.s - 16bit→32bit 切替とVGA表示
[org 0x7C00]
[bits 16]

start:
    cli
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00

    ; A20 有効化（Fast A20: port 0x92）
    in  al, 0x92
    or  al, 0x02
    out 0x92, al

    ; GDT をロード
    lgdt [gdt_descriptor]

    ; CR0.PE = 1 でプロテクトモードへ
    mov eax, cr0
    or  eax, 1
    mov cr0, eax

    ; CS を 0x08（コードセグメント）にして 32bitへ（32bitオフセット指定）
    jmp dword 0x08:pm32_start

[bits 32]
pm32_start:
    cld
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, 0x00300000

    ; VGA テキストバッファに表示
    mov esi, msg_pm
    mov edi, 0xB8000
    mov bl, 0x0F
.next:
    lodsb
    test al, al
    jz .done
    mov [edi], al
    mov [edi+1], bl
    add edi, 2
    jmp .next
.done:
    cli
.halt:
    hlt
    jmp .halt

; GDT定義（null / code / data）
; - `0x9A`=コード用アクセスバイト、`0x92`=データ用アクセスバイト
; - `0xCF`=4KB粒度+32ビットフラグ+上位リミット

align 8
gdt_start:
    dq 0x0000000000000000          ; null descriptor
    dq 0x00CF9A000000FFFF          ; code: base=0, limit=4GB, 32-bit, RX
    dq 0x00CF92000000FFFF          ; data: base=0, limit=4GB, 32-bit, RW
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start


msg_pm db 'Now in 32-bit protected mode! Hello VGA!', 0

times 510 - ($ - $$) db 0
dw 0xAA55
```

### ステップ 3: Makefile の作成

```makefile
# Makefile for Day 02 - Protected Mode Switch

AS   = nasm
QEMU = qemu-system-i386

BOOT_SRC = boot.s
OS_IMG   = os.img

all: $(OS_IMG)
	@echo "✅ Day 02: プロテクトモードブートイメージ作成完了"
	@echo "🚀 実行: make run"

$(OS_IMG): $(BOOT_SRC)
	@echo "🔨 アセンブルしています..."
	$(AS) -f bin $(BOOT_SRC) -o $(OS_IMG)
	@echo "📏 ファイルサイズ確認..."
	@if [ `wc -c < $(OS_IMG)` -eq 512 ]; then \
	  echo "✅ 512バイトOK"; \
	else \
	  echo "❌ エラー: 512バイトではありません"; exit 1; \
	fi

run: $(OS_IMG)
	@echo "🚀 QEMUで起動しています..."
	$(QEMU) -fda $(OS_IMG) -boot a

debug: $(OS_IMG)
	@echo "🔍 デバッグモードで起動..."
	$(QEMU) -fda $(OS_IMG) -boot a -serial stdio -monitor tcp:127.0.0.1:4444,server,nowait

clean:
	@echo "🧹 クリーンアップ..."
	rm -f $(OS_IMG)
	@echo "✅ 完了"

.PHONY: all run debug clean
```

### ステップ 4: ビルドと実行

```bash
cd day02
make clean
make all
make run
```

QEMU 画面に白文字で「Now in 32-bit protected mode! Hello VGA!」が表示されれば成功です。

## コード解説

### GDT 構造の詳細図解

#### GDT メモリレイアウト

```
GDT全体図:
+---------+--------+--------+--------+--------+--------+--------+--------+
| Byte 7  | Byte 6 | Byte 5 | Byte 4 | Byte 3 | Byte 2 | Byte 1 | Byte 0 |
+---------+--------+--------+--------+--------+--------+--------+--------+

エントリ0（NULL）: 0x0000000000000000
+---------+--------+--------+--------+--------+--------+--------+--------+
|   00    |   00   |   00   |   00   |   00   |   00   |   00   |   00   |
+---------+--------+--------+--------+--------+--------+--------+--------+

エントリ1（CODE）: 0x00CF9A000000FFFF
+---------+--------+--------+--------+--------+--------+--------+--------+
|   00    |   CF   |   9A   |   00   |   00   |   00   |   FF   |   FF   |
+---------+--------+--------+--------+--------+--------+--------+--------+
    ↑        ↑        ↑        ↑      ←Base→      ←----Limit---→
Base[31:24] Flags   Access Base[23:16]  Address      0xFFFFF
            0xC=Granular+32bit  0x9A    0x00000000   4GB

エントリ2（DATA）: 0x00CF92000000FFFF
+---------+--------+--------+--------+--------+--------+--------+--------+
|   00    |   CF   |   92   |   00   |   00   |   00   |   FF   |   FF   |
+---------+--------+--------+--------+--------+--------+--------+--------+
```

#### セレクタから GDT エントリへの変換

```
セレクタ構造:
15                    3  2   0
+--------------------+--+---+
|      インデックス    |TI|RPL|
+--------------------+--+---+

例: CS = 0x08 = 0000 1000
- インデックス = 1 → GDTエントリ1（CODE）
- TI = 0（GDT使用）
- RPL = 0（カーネル特権）

例: DS = 0x10 = 0001 0000
- インデックス = 2 → GDTエントリ2（DATA）
- TI = 0（GDT使用）
- RPL = 0（カーネル特権）
```

#### アクセス権の詳細

| フィールド         | コード(0x9A) | データ(0x92) | 意味                    |
| ------------------ | ------------ | ------------ | ----------------------- |
| **P** (Present)    | 1            | 1            | セグメント存在          |
| **DPL** (特権)     | 00           | 00           | カーネルレベル          |
| **S** (タイプ)     | 1            | 1            | コード/データセグメント |
| **E** (実行可)     | 1            | 0            | 実行可能/不可           |
| **DC**             | 0            | 0            | 拡張方向                |
| **RW**             | 1            | 1            | 読み書き可能            |
| **A** (アクセス済) | 0            | 0            | 未使用時は 0            |

#### フラグの詳細

| ビット  | 名前      | 値  | 意味                |
| ------- | --------- | --- | ------------------- |
| **G**   | 粒度      | 1   | 4KB ページ単位      |
| **D/B** | サイズ    | 1   | 32 ビットセグメント |
| **L**   | 64 ビット | 0   | 32 ビットモード     |
| **AVL** | 使用可能  | 0   | OS 使用可能ビット   |

#### プロテクトモード移行の流れ

```
ステップ1: GDT準備
[リアルモード] gdt_start のアドレスを lgdt で登録

ステップ2: PE設定
CR0.PE = 1 でプロテクトモード有効化

ステップ3: セグメント更新
far jump 0x08:pm32_start でCS更新（32ビットモードへ）

ステップ4: データセグメント設定
mov ax, 0x10  ; データセグメントセレクタ
mov ds, ax    ; すべてのデータセグメントを更新
```

### CR0.PE と Far Jump

-   `mov cr0, eax` で PE を立てた直後、命令プリフェッチに 16 ビット命令が残る可能性があるため、far jump で CS を明示的に再読み込みし、32 ビットコードへ移行します。

## トラブルシューティング

1. 画面が真っ黒のまま
    - `lgdt` のオペランド（`gdt_descriptor`）が正しいか
    - far jump のセレクタ（0x08）、`[bits 32]` の位置
2. リセットがかかる/ハングする
    - A20 有効化（0x92 ポート）の手順
    - CR0.PE 設定前後の手順の順序
3. 文字化けする
    - VGA バッファ 0xB8000 に 2 バイト（文字+属性）で書いているか

## セグメント保護機能の仕組み

### 同じアドレス範囲でコードセグメントとデータセグメントが機能する方法

コードセグメント（0x08）とデータセグメント（0x10）は確かに同じアドレス範囲（0x00000000-0xFFFFFFFF）をカバーしていますが、**異なるアクセス権限**を持っています：

**コードセグメント（0x08）**: アクセスバイト `0x9A`

-   ✅ 実行可能（命令を実行できる）
-   ✅ 読み取り可能（定数を読める）
-   ❌ **書き込み不可**（変更できない）

**データセグメント（0x10）**: アクセスバイト `0x92`

-   ✅ 読み取り可能（データを読める）
-   ✅ 書き込み可能（データを変更できる）
-   ❌ **実行不可**（コードとして実行できない）

### 実践的な例

```assembly
; 同じ物理アドレス 0x1000 でも、使用するセグメントによってアクセスが変わる：

; コードセグメントセレクタ使用（CS = 0x08）
jmp 0x08:0x1000        ; ✅ 0x1000で命令実行（許可）
mov eax, cs:[0x1000]   ; ✅ 0x1000から定数読み取り（許可）
mov cs:[0x1000], eax   ; ❌ 保護違反！（コードセグメントへの書き込み）

; データセグメントセレクタ使用（DS = 0x10）
mov eax, [0x1000]      ; ✅ 0x1000からデータ読み取り（許可）
mov [0x1000], eax      ; ✅ 0x1000にデータ書き込み（許可）
jmp 0x10:0x1000        ; ❌ 保護違反！（データセグメントからの実行）
```

### デフォルトセグメント選択

セグメントを明示的に指定しない場合、CPU は命令の種類に基づいて自動的に選択します：

| 命令の種類         | デフォルトセグメント | 例                           |
| ------------------ | -------------------- | ---------------------------- |
| **命令フェッチ**   | CS（コード）         | `call function`, `jmp label` |
| **スタック操作**   | SS（スタック）       | `push eax`, `pop ebx`        |
| **データアクセス** | DS（データ）         | `mov eax, [0x1000]`          |
| **文字列の送信先** | ES（エキストラ）     | `stosb`, `rep movsb`         |

```assembly
; これらの命令は異なるデフォルトセグメントを使用：
mov eax, 0x1000        ; 即値代入（メモリアクセスなし）
mov eax, [0x1000]      ; DS:0x1000（データ読み取り）
push eax               ; SS:ESP（スタック書き込み）
call 0x2000            ; CS:0x2000（コード実行）
```

### メモリ保護の実際の動作

この仕組みにより、アドレス範囲が重複していても**メモリ保護**が実現されます：

```
物理メモリアドレス 0x1000:
┌─────────────────────────────────────┐
│      同じメモリ位置                 │
├─────────────────────────────────────┤
│ CS (0x08) 経由: 読み取り/実行OK     │
│                 書き込み禁止        │
├─────────────────────────────────────┤
│ DS (0x10) 経由: 読み取り/書き込みOK │
│                 実行禁止            │
└─────────────────────────────────────┘
```

これは現代 OS セキュリティの基盤となる技術で、コードインジェクションを防ぎ、重要なシステムコードを偶発的な変更から保護します。

## 理解度チェック

1. A20 ラインが無効だと何が起きる？
2. GDT のアクセスバイト 0x9A/0x92 はそれぞれどんな意味？
3. Far jump を挟まずに PE=1 にしたらどうなる可能性がある？
4. 32 ビット移行後に BIOS 割り込みを使用しない理由は？
5. 有効な命令が含まれていても、なぜデータセグメントからコードを実行できないのか？
6. コードセグメントに書き込もうとするとどうなるか？

## 次のステップの準備

-   ✅ A20 ライン有効化
-   ✅ GDT の構築と登録
-   ✅ プロテクトモード切替と far jump
-   ✅ VGA バッファ直接出力

明日の Day 03 では、VGA テキスト表示を発展させ、色・カーソル・スクロールなどを扱います。
