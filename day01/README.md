# Day 01: PC ブートの基礎 🖥️

## 本日のゴール

x86 コンピュータの起動プロセスを理解し、最小限のブートローダーを作成して"Hello OS!"を表示する。

## 背景

OS 開発の第一歩は、コンピュータの起動プロセスを理解することです。電源投入から BIOS がハードウェアを初期化し、ブートデバイスから最初のプログラム（ブートローダー）を読み込んで実行します。この日はその基礎を学び、実際に動作するブートローダーを作成します。

## 新しい概念

-   **ブートセクタ (Boot Sector)**: BIOS が最初に読み込む 512 バイトのデータ領域。なぜ 512 バイトなのかはハードウェアの制約によるもので、BIOS がこれをメモリの 0x7C00 番地にロードして実行を開始する。
-   **org 0x7c00**: アセンブラのディレクティブで、プログラムがメモリの 0x7C00 番地に配置されることを宣言。このアドレスは歴史的経緯として CP/M-86 との互換性を保つために選ばれた。
-   **リアルモード**: 16 ビット実行環境。現代の 64 ビット CPU でも電源投入時はこのモードから始まる。

## 学習内容

-   **x86 PC の起動プロセス** - コンピュータが電源投入後にどう動作するか
-   **BIOS（Basic Input/Output System）** - ハードウェアと OS の橋渡し
-   **MBR（Master Boot Record）** - 最初に実行されるプログラム
-   **16 ビットリアルモード** - x86 の歴史的な実行モード
-   **アセンブリ言語の基礎** - CPU と直接対話する言語

## タスクリスト

-   [ ] boot.s ファイルを作成し、アセンブリコードを記述する
-   [ ] BIOS 割り込みを使って画面に文字を表示する関数を実装する
-   [ ] 512 バイトのブートシグネチャ（0xAA55）を追加する
-   [ ] Makefile を作成してビルド環境を構築する
-   [ ] QEMU でブートローダーを実行して"Hello OS!"が表示されることを確認する

## 前提知識の確認

### 必要な知識

-   **C 言語の基礎**: 関数、変数、ポインタの概念
-   **16 進数**: 0x7C00、0x10 などの表記に慣れておく
-   **コンピュータの基本概念**: CPU、メモリ、レジスタの存在を知っている

### 今日新しく学ぶこと

-   **x86 レジスタ**: CPU 内部の高速記憶装置
-   **セグメントレジスタ**: メモリ管理の古い方式
-   **BIOS 割り込み**: OS がない状態でのハードウェア制御
-   **アセンブリ言語**: CPU への直接命令

## x86 PC の起動プロセス理解

### 1. 電源投入から BIOS まで

```
電源投入 → CPU初期化 → BIOS起動 → ハードウェア検出 → ブートローダー探索
```

1. **CPU 初期化**: 電源が入ると、CPU は決められたアドレス（0xFFFFFFF0）から実行開始
2. **BIOS 実行**: ROM 内の BIOS プログラムがハードウェアをチェック
3. **ブートデバイス探索**: フロッピーディスク、ハードディスクの順番で起動可能なデバイスを探索
4. **MBR 読み込み**: 見つかったデバイスの最初の 512 バイトを 0x7C00 番地にロード
5. **制御移行**: 0x7C00 から実行開始（ここが私たちのプログラム！）

### 2. リアルモードとレジスタ

**リアルモード**は 8086 CPU 互換の 16 ビット実行モードです。現代の 64 ビット CPU でも、電源投入時は必ずこのモードから開始します。

#### 主要レジスタ（CPU の内部記憶装置）

| レジスタ | 役割                           | 例                   |
| -------- | ------------------------------ | -------------------- |
| **AX**   | アキュムレータ（計算用）       | 計算結果の一時保存   |
| **BX**   | ベースレジスタ（アドレス計算） | メモリアドレスの計算 |
| **CX**   | カウンタレジスタ（ループ用）   | 繰り返し回数の管理   |
| **DX**   | データレジスタ（I/O 用）       | 入出力データの保存   |

#### セグメントレジスタ（メモリ領域指定）

| レジスタ | 役割                 | 説明                     |
| -------- | -------------------- | ------------------------ |
| **DS**   | データセグメント     | データ格納領域の指定     |
| **ES**   | エクストラセグメント | 追加データ領域           |
| **SS**   | スタックセグメント   | 関数呼び出し時の退避領域 |
| **CS**   | コードセグメント     | 実行中のプログラム領域   |

## 実践: 最初のブートローダー作成

### ステップ 1: 開発環境の確認

まず、必要なツールがインストールされているか確認しましょう：

```bash
# クロスコンパイラの確認
i686-elf-gcc --version

# アセンブラの確認
nasm --version

# エミュレータの確認
qemu-system-i386 --version
```

もしインストールされていない場合：

```bash
# macOSの場合
brew install i686-elf-gcc nasm qemu

# Ubuntuの場合
sudo apt install gcc-multilib nasm qemu-system-i386
```

### ステップ 2: プロジェクト構造の理解

今日作成するファイル構成：

```
day01/
├── README.md          # このファイル
├── boot.s            # ブートローダーのアセンブリコード
├── Makefile          # ビルド自動化スクリプト
└── os.img           # 作成される起動可能イメージ（実行後）
```

### ステップ 3: ブートローダーのアセンブリコード作成

`boot.s`ファイルを作成し、以下の内容を入力してください：

```assembly
; boot.s - 最初のブートローダー
; x86リアルモード（16ビット）で動作

[org 0x7C00]          ; BIOSが私たちのコードを0x7C00番地にロードすることを指定
[bits 16]             ; 16ビットモードでアセンブル

start:
    ; === レジスタ初期化 ===
    ; セグメントレジスタをすべて0に設定（安全のため）
    cli                ; 割り込み無効化（重要な初期化中は邪魔されたくない）
    xor ax, ax         ; AX = 0（同じレジスタ同士のXORで0になる）
    mov ds, ax         ; データセグメント = 0
    mov es, ax         ; エクストラセグメント = 0
    mov ss, ax         ; スタックセグメント = 0
    mov sp, 0x7C00     ; スタックポインタをブートローダーの直前に設定

    ; === メッセージ表示 ===
    ; "Hello OS!" を画面に表示
    mov si, hello_msg  ; SI レジスタにメッセージのアドレスを設定
    call print_string  ; 文字列表示関数を呼び出し

    ; === 無限ループ ===
    ; プログラムを終了させないために無限ループ
infinite_loop:
    hlt               ; CPUを休ませる（省電力）
    jmp infinite_loop ; 無限ループ

; === 文字列表示関数 ===
; 入力：SI = 文字列のアドレス
; 破壊：AX, BX
print_string:
    mov ah, 0x0E      ; BIOS機能：文字表示（Teletype output）
.next_char:
    lodsb             ; SI が指すメモリから1バイト読み込み、AL に格納、SI++
    cmp al, 0         ; 文字が0（文字列終端）か確認
    je .done          ; 0なら終了
    int 0x10          ; BIOS割り込み呼び出し（文字表示）
    jmp .next_char    ; 次の文字へ
.done:
    ret               ; 呼び出し元に戻る

; === データ部 ===
hello_msg db 'Hello OS! Boot successful!', 13, 10, 0
    ; db = define byte（バイト定義）
    ; 13 = キャリッジリターン（CR）
    ; 10 = ラインフィード（LF）
    ; 0 = 文字列終端

; === ブートシグネチャ ===
; 512バイトちょうどにするため、残りを0で埋める
times 510 - ($ - $$) db 0  ; 現在位置から510バイトまで0で埋める
dw 0xAA55                  ; ブートシグネチャ（これがないとBIOSが認識しない）
```

### ステップ 4: Makefile 作成

`Makefile`を作成して、ビルドプロセスを自動化します：

```makefile
# Makefile for Day 01 - Basic Boot
# シンプルなブートローダー用ビルドスクリプト

# === ツール設定 ===
AS = nasm              # アセンブラ
QEMU = qemu-system-i386 # エミュレータ

# === ファイル名設定 ===
BOOT_SRC = boot.s      # ソースファイル
OS_IMG = os.img        # 起動イメージ

# === メインターゲット ===
# 'make' または 'make all' で実行される
all: $(OS_IMG)
 @echo "✅ ブートローダーの作成が完了しました！"
 @echo "📁 $(OS_IMG) が作成されました"
 @echo ""
 @echo "🚀 実行するには: make run"
 @echo "🧹 クリーンアップ: make clean"

# === イメージファイル作成 ===
$(OS_IMG): $(BOOT_SRC)
 @echo "🔨 ブートローダーをアセンブルしています..."
 $(AS) -f bin $(BOOT_SRC) -o $(OS_IMG)
 @echo "📏 ファイルサイズ確認中..."
 @ls -l $(OS_IMG) | awk '{print "   サイズ: " $$5 " バイト"}'
 @if [ `wc -c < $(OS_IMG)` -eq 512 ]; then \
  echo "✅ 正しく512バイトになりました！"; \
 else \
  echo "❌ エラー：512バイトではありません"; \
  exit 1; \
 fi

# === QEMU実行 ===
run: $(OS_IMG)
 @echo "🚀 QEMUでOSを起動しています..."
 @echo "💡 終了するには QEMUウィンドウを閉じるか Ctrl+C を押してください"
 @echo ""
 $(QEMU) -fda $(OS_IMG) -boot a


# === デバッグ実行 ===
# シリアル出力付きで実行（デバッグ時に便利, Day4以降で使用）
debug: $(OS_IMG)
 @echo "🔍 デバッグモードで起動しています..."
 $(QEMU) -fda $(OS_IMG) -boot a -serial stdio -monitor tcp:127.0.0.1:4444,server,nowait

# === クリーンアップ ===
clean:
 @echo "🧹 生成されたファイルを削除しています..."
 rm -f $(OS_IMG)
 @echo "✅ クリーンアップ完了"

# === ヘルプ ===
help:
 @echo "=== Day 01 ブートローダー開発 ==="
 @echo ""
 @echo "利用可能なコマンド:"
 @echo "  make all     - ブートローダーをビルド"
 @echo "  make run     - QEMUで実行"
 @echo "  make debug   - デバッグモードで実行"
 @echo "  make clean   - 生成ファイルを削除"
 @echo "  make help    - このヘルプを表示"
 @echo ""
 @echo "📚 学習ポイント:"
 @echo "  - 512バイトのブートセクター"
 @echo "  - BIOS割り込みによる文字表示"
 @echo "  - x86リアルモードの基礎"

# === Phonyターゲット ===
# ファイル名と重複しないよう宣言
.PHONY: all run debug clean help
```

### ステップ 5: ビルドと実行

#### 1. ビルド実行

```bash
cd day01
make all
```

成功すると以下のような出力が表示されます：

```
🔨 ブートローダーをアセンブルしています...
📏 ファイルサイズ確認中...
   サイズ: 512 バイト
✅ 正しく512バイトになりました！
✅ ブートローダーの作成が完了しました！
```

#### 2. 実行

```bash
make run
```

QEMU ウィンドウが開き、「Hello OS! Boot successful!」が表示されれば成功です！

## コード解説：行ごとの詳細理解

### アセンブリ命令の理解

#### 基本命令

| 命令  | 意味               | 例                                         |
| ----- | ------------------ | ------------------------------------------ |
| `mov` | データ移動         | `mov ax, 0` → AX に 0 を代入               |
| `xor` | 排他的論理和       | `xor ax, ax` → AX = 0（高速な 0 代入方法） |
| `cmp` | 比較               | `cmp al, 0` → AL と 0 を比較               |
| `je`  | 等しければジャンプ | `je .done` → 比較結果が等しければ.done へ  |
| `jmp` | 無条件ジャンプ     | `jmp infinite_loop` → 無限ループ           |
| `int` | 割り込み呼び出し   | `int 0x10` → BIOS 画面表示機能             |
| `hlt` | CPU を停止         | 次の割り込みまで待機（省電力）             |

#### BIOS 割り込み 0x10 の詳細

```assembly
mov ah, 0x0E    ; 機能番号：Teletype Output
mov al, 'A'     ; 表示文字
int 0x10        ; 実行 → 画面に'A'が表示される
```

-   **AH = 0x0E**: 文字表示機能を指定
-   **AL**: 表示する文字の ASCII コード
-   **INT 0x10**: BIOS 画面サービス呼び出し

### メモリレイアウトの理解

#### リアルモード（16 ビット）メモリマップ

| アドレス     | サイズ | 用途                                                                     | 重要度     |
| ------------ | ------ | ------------------------------------------------------------------------ | ---------- |
| `0x00000000` | 1KB    | 割り込みベクタテーブル（IVT）<br>- BIOS 割り込み関数のアドレス           | ⭐⭐⭐     |
| `0x00000400` | 254B   | BIOS データエリア<br>- ハードウェア情報                                  | ⭐⭐       |
| `0x00000500` | ~30KB  | 空き領域（DOS 時代の名残）<br>- 自由に使用可能                           | ⭐         |
| `0x00007C00` | 512B   | ブートセクタ（私たちのコード）<br>- BIOS がここにブートローダーを配置    | ⭐⭐⭐⭐⭐ |
| `0x00007E00` | ~608KB | 空き領域<br>- カーネル読み込み先<br>- スタック領域として使用可能         | ⭐⭐       |
| `0x000A0000` | 128KB  | ビデオ RAM<br>- VGA テキスト：`0xB8000`〜<br>- グラフィック：`0xA0000`〜 | ⭐⭐⭐⭐   |
| `0x000C0000` | 256KB  | BIOS 拡張 ROM<br>- アダプタカード用                                      | ⭐         |
| `0x000F0000` | 64KB   | システム ROM（BIOS 本体）<br>- 起動時最初に実行される                    | ⭐⭐       |

#### 重要なアドレスの詳細

**0x7C00（ブートローダー）**

-   歴史的経緯：CP/M-86 の互換性のため
-   512 バイト厳守：BIOS の仕様
-   最後の 2 バイトは必ず 0x55AA（ブートシグネチャ）

**0xB8000（VGA テキストバッファ）**

-   80×25 文字 = 2000 文字
-   各文字 2 バイト（文字コード + 属性）
-   総サイズ：4000 バイト

#### メモリ配置の実例

```
実際の配置例（Day 01実行時）:

0x7C00  |48 65 6C 6C| "Hello OS!" メッセージ
0x7C04  |6F 20 4F 53|
...     |    ...     |
0x7DFE  |55 AA      | ブートシグネチャ
0x7E00  |00 00 00 00| 空き領域開始
```

### ブートシグネチャの重要性

```assembly
times 510 - ($ - $$) db 0  ; 余った領域を0で埋める
dw 0xAA55                  ; マジックナンバー
```

-   `$`: 現在の位置
-   `$$`: セクション開始位置
-   `510 - ($ - $$)`: 残りバイト数を計算
-   `0xAA55`: BIOS が「これは起動可能なセクタだ」と認識するマジックナンバー

## トラブルシューティング

### よくあるエラーと解決法

#### 1. "nasm: command not found"

```bash
# macOSの場合
brew install nasm

# Ubuntuの場合
sudo apt install nasm
```

#### 2. "qemu-system-i386: command not found"

```bash
# macOSの場合
brew install qemu

# Ubuntuの場合
sudo apt install qemu-system-i386
```

#### 3. "❌ エラー：512 バイトではありません"

-   ブートセクターは必ず 512 バイトである必要があります
-   メッセージが長すぎる場合は短縮してください
-   `times 510 - ($ - $$) db 0` の計算を確認してください

#### 4. 画面に何も表示されない

-   BIOS 割り込み設定を確認：`mov ah, 0x0E`
-   文字列が 0 で終わっていることを確認
-   セグメントレジスタの初期化を確認

#### 5. QEMU が起動しない

```bash
# 詳細なエラー情報を表示
qemu-system-i386 -drive file=os.img,format=raw,if=floppy -boot a -serial stdio
```

## 理解度チェック

以下の質問に答えられるか確認してください：

### 基礎理解

1. **BIOS の役割は何ですか？**
2. **リアルモードとは何ですか？**
3. **0x7C00 という番地の意味は？**
4. **なぜ 512 バイトちょうどである必要があるのですか？**

### 技術詳細

5. **AX、BX、CX、DX レジスタの役割を説明できますか？**
6. **INT 0x10 の 0x0E 機能は何をしますか？**
7. **0xAA55 の意味は？**
8. **`times 510 - ($ - $$) db 0`は何をしていますか？**

### 応用問題

9. **メッセージを変更してみましょう**
10. **別の色で文字を表示してみましょう（ヒント：BL レジスタ）**

## 次のステップの準備

明日の Day 02 では、この 16 ビットリアルモードから 32 ビットプロテクトモードへ移行します。今日学んだ内容をしっかり理解しておきましょう：

-   ✅ x86 の起動プロセス
-   ✅ リアルモードとレジスタ
-   ✅ BIOS 割り込みの基本
-   ✅ アセンブリ言語の基礎
-   ✅ メモリレイアウト

### 推奨復習項目

1. **アセンブリ命令を声に出して読む**（mov、xor、cmp など）
2. **レジスタの役割を紙に書いて整理**
3. **0x7C00 がなぜ特別なのか理解**
4. **ブートシーケンスの流れを図解**

### 実験的改造案

意欲的な学習者向けの追加課題：

1. **カウントダウン表示**: 3、2、1... と表示してからメッセージ
2. **カラフル表示**: 複数色での文字表示
3. **キー入力待ち**: キーボード入力を待つ機能追加
4. **時刻表示**: BIOS 時刻取得と表示

---

🎉 **お疲れさまでした！**

初めてのブートローダーが動作したでしょうか？これでコンピュータの「心臓」とも言える起動プロセスの基礎を理解できました。明日はさらに進歩して、現代的な 32 ビットプロテクトモードの世界に足を踏み入れます！
