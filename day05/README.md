# Day 05: Interrupt Infrastructure ⚙️

## Today's Goal

Implement the basics of the x86 interrupt system, build an IDT, and establish an environment that can handle CPU exceptions.

## Background

While we've built a freestanding C environment through Day 4, OS development requires proper handling of program errors and hardware events. Today we'll build an IDT as the foundation of the interrupt system and establish a CPU exception handling environment.

## New Concepts

-   **Interrupt**: "Event notification" mechanism for the CPU. Responds to asynchronous requests from hardware or software, temporarily suspending current processing to execute a handler. Core concept for improving OS responsiveness.
-   **IRQ (Interrupt ReQuest)**: Physical lines through which interrupt request signals pass (interrupt lines). PIC manages multiple IRQs and transmits to CPU. IRQ 0-15 are standardly assigned, corresponding to keyboard, timer, and other devices.
-   **PIC (Programmable Interrupt Controller)**: 8259A chip that bundles IRQs from multiple devices and efficiently transmits to CPU. In BIOS settings, remaps IRQ0-15 to 32-47 for OS interrupt management.
-   **IDT (Interrupt Descriptor Table)**: Address table for interrupt handlers. Defines which functions to call when CPU exceptions or hardware interrupts occur.

## Learning Content

-   **IDT Basics**: Understanding structure and role of Interrupt Descriptor Table
-   **Exception System**: Classification and handling methods for CPU exceptions (0-31)
-   **Assembly Cooperation**: Collaborative operation between ISR stubs and C handlers
-   **Table Management**: Implementation of IDT registration using `lidt` instruction
-   **Debug Techniques**: Debug methods using software interrupts (`int 0x03`)
-   **Error Handling**: Information display and recovery from CPU exceptions

【Terminology】Difference between Exceptions and IRQs

-   Exception: Synchronous internal CPU events (division by zero, invalid opcode, page fault, etc.). Occur "at that moment" of instruction execution.
-   IRQ (Interrupt Request): Asynchronous events from devices (timer, keyboard, etc.). Generated by external signals.

【IDT Gate Reality】

-   Table entry that records "which function to jump to for which interrupt number". In 32-bit OS, "interrupt gate (0x8E)" is the standard.

## Task List

-   [ ] Define IDT structure and implement function to set entries
-   [ ] Create ISR stubs (0-31) in interrupt.s and perform register save/restore
-   [ ] Initialize IDT in kernel.c and implement representative exception handlers
-   [ ] Register IDT with processor using lidt instruction
-   [ ] Test exception handling with software interrupt (int 0x03)
-   [ ] Confirm handlers work with CPU exceptions like division by zero

## Prerequisites Check

### Required Knowledge

-   **Day 01-02**: Bootloader, GDT, protected mode switching
-   **Day 03-04**: freestanding C, VGA/serial output, inline assembly
-   **C Language**: Structures, function pointers, bit operations, header file management
-   **Assembly Basics**: Registers, stack operations, function calling conventions

### What's New Today

-   **IDT Structure**: Entry layout (offset, selector, attribute fields)
-   **Exception Classification**: Difference between CPU exceptions and hardware interrupts
-   **Error Codes**: Presence/absence of error information by exception and handling method
    -   Not all exceptions have error codes (division by zero #DE, etc. don't)
    -   With error codes: Page fault #PF (violation address), general protection fault #GP, etc.
    -   Without error codes: Division by zero #DE, invalid opcode #UD, etc.
    -   ISR pushes dummy value even for exceptions without error codes to align stack
-   **Register Preservation**: CPU state save/restore mechanism during interrupts
-   **Calling Conventions**: Safe transition from assembly to C functions

## Approach and Configuration

Like Day 03/04, keep assembly minimal (under boot/) and manage IDT in C.

```
├── boot
│   ├── boot.s            # 16-bit: A20, built-in GDT, load kernel with INT 13h, PE switch
│   ├── kernel_entry.s    # 32-bit: segment/stack setup → kmain()
│   └── interrupt.s       # Exception ISR stubs (0-31) and common entry
├── io.h                  # inb/outb/io_wait (C inline asm)
├── kernel.c              # IDT construction, exception handlers, operation demo
├── vga.h                 # VGA API (C)
└── Makefile              # Link boot + kernel + interrupt to generate os.img
```

### Architecture Design Points

#### Continue C-Centered Development

Continue the pattern established in Day 03/04:

-   **Minimal Assembly**: Only interrupt handler stubs written in assembly
-   **C Main Implementation**: IDT management and exception processing logic implemented in C
-   **Gradual Construction**: Start with basic exceptions, gradually expand to hardware interrupts

#### New Additional Elements

-   **interrupt.s**: Assembly stubs for CPU exceptions (ISR0-ISR31)
-   **IDT Management**: IDT structures and configuration functions in kernel.c
-   **Exception Handlers**: Analysis and display of exception information in C

See `day05_completed/` for reference to the completed version.

## Implementation Guide

### 1. Basic Concepts of Interrupt Handling

#### x86 Interrupt System Structure

The x86 processor interrupt system consists of the following elements:

1. **IDT (Interrupt Descriptor Table)**: Address table for interrupt handlers
2. **IDT Entry**: Stores handler information for each interrupt/exception
3. **ISR (Interrupt Service Routine)**: Actual interrupt handler code
4. **IDTR**: Register indicating IDT location and size

#### Processing Flow

1. **Exception occurs** → CPU automatically references IDT
2. **ISR stub** → Save registers, call C handler
3. **C handler** → Analyze exception information and appropriate processing
4. **Return** → Restore registers, return to original processing

### 2. IDT Structure Implementation

#### IDT Entry Structure

Each IDT entry is an 8-byte structure containing the following information:

```c
// IDT entry (32-bit interrupt gate)
struct idt_entry {
    uint16_t base_low;   // Handler address lower 16 bits
    uint16_t sel;        // Segment selector (usually 0x08)
    uint8_t  always0;    // Always 0 (reserved area)
    uint8_t  flags;      // Attribute flags (Present, DPL, Type)
    uint16_t base_high;  // Handler address upper 16 bits
} __attribute__((packed));
```

#### Flag Field Details

| Bit | Meaning | Description                                  |
| --- | ------- | -------------------------------------------- |
| 7   | Present | Entry is valid (1=valid, 0=invalid)         |
| 6-5 | DPL     | Privilege level (0=kernel, 3=user)          |
| 4   | Storage | Always 0 (system descriptor)                |
| 3-0 | Type    | Gate type (0xE=32-bit interrupt gate)       |

### 3. IDT Management System

```c
// ----- IDT Construction -----
struct idt_entry {
    uint16_t base_low;   // Handler lower 16 bits
    uint16_t sel;        // Segment selector (usually 0x08)
    uint8_t always0;     // Always 0
    uint8_t flags;       // 0x8E = present/privilege 0/32bit interrupt gate
    uint16_t base_high;  // Handler upper 16 bits
} __attribute__((packed));


struct idt_ptr {
    uint16_t limit;  // IDT size - 1
    uint32_t base;   // IDT start address
} __attribute__((packed));

#define IDT_SIZE 256
#define IDT_FLAG_PRESENT_DPL0_32INT 0x8E

static struct idt_entry idt[IDT_SIZE];
static struct idt_ptr idtr;

static inline void lidt(void* idtr_ptr) {
    __asm__ volatile("lidt (%0)" ::"r"(idtr_ptr));
}

static void set_idt_gate(int n, uint32_t handler) {
    idt[n].base_low = handler & 0xFFFF;
    idt[n].sel = 0x08;
    idt[n].always0= 0;
    idt[n].flags = IDT_FLAG_PRESENT_DPL0_32INT;
    idt[n].base_high = (handler >> 16) & 0xFFFF;
}
static void load_idt(void) {
    idtr.limit = sizeof(idt) - 1;
    idtr.base = (uint32_t)&idt[0];
    lidt(&idtr);
}
```

### 2. ISR Stubs (Assembly)

Define stubs for exceptions 0-31 in `boot/interrupt.s`, save registers at common entry → pass to C function.

```assembly
; Exception ISR stubs and common handler (32-bit)
[bits 32]

%macro ISR_NOERR 1        ; Exception without error code
  global isr%1
isr%1:
  push dword 0            ; Push dummy error code
  push dword %1           ; Vector number
  jmp isr_common
%endmacro

%macro ISR_ERR 1          ; Exception with error code
  global isr%1
isr%1:
  push dword %1           ; Vector number (CPU already pushed error code)
  jmp isr_common
%endmacro

extern isr_handler_c      ; C-side handler

isr_common:
  pusha                   ; Save general registers
  cld
  mov eax, esp            ; Pass ESP: [errcode][vec][pusha...] 
  push eax
  call isr_handler_c
  add esp, 4
  popa
  add esp, 8              ; Pop vec + errcode
  iretd

; Representative exceptions
ISR_NOERR 0    ; Divide-by-zero
ISR_NOERR 3    ; Breakpoint
ISR_NOERR 6    ; Invalid Opcode
ISR_ERR   13   ; General Protection Fault
ISR_ERR   14   ; Page Fault
; ... Define up to 31 as needed
```

Note:

-   Use `ISR_ERR` for exceptions with error codes (#DF, #TS, #NP, #SS, #GP, #PF, etc.).
-   In learning phase, starting with representative ones (0, 3, 6, 13, 14, etc.) is OK.

### 3. C-side Handler (Exception Display)

Prepare handlers like the following in `kernel.c`. Output information via VGA or serial.

#### Detailed Stack State Diagram

**Stack changes during interrupt occurrence:**

```
Stack before interrupt (during user application execution):
Higher Address
+------------------+
|   User Data      |
|       ...        |
+------------------+ <- ESP (application)
|                  |
Lower Address


During interrupt (CPU automatically pushes):
+------------------+
|   User Data      |
|       ...        |
+------------------+
|      EFLAGS      | <- CPU automatic
+------------------+
|        CS        | <- CPU automatic
+------------------+
|       EIP        | <- CPU automatic
+------------------+
|   Error Code     | <- CPU automatic (not for all exceptions)
+------------------+ <- ESP (during interrupt)


After ISR stub processing (pusha + vector number):
+------------------+
|   User Data      |
+------------------+
|      EFLAGS      |
+------------------+
|        CS        |
+------------------+
|       EIP        |
+------------------+
|   Error Code     |
+------------------+
|   Vector Number  | <- ISR stub pushes
+------------------+
|       EAX        | <- pusha
|       ECX        | <- pusha
|       EDX        | <- pusha
|       EBX        | <- pusha
|   ESP (dummy)    | <- pusha
|       EBP        | <- pusha
|       ESI        | <- pusha
|       EDI        | <- pusha
+------------------+ <- ESP (C function call time)
```

**Correspondence between isr_stack structure and stack:**

```c
struct isr_stack {
    uint32_t edi, esi, ebp, esp_dummy, ebx, edx, ecx, eax; // pusha order (reverse)
    uint32_t int_no;   // Vector number
    uint32_t err_code; // Error code (0 if none)
    // EIP, CS, EFLAGS pushed by CPU are above this
};

// Usage example on C function side
void isr_handler_c(struct isr_stack* frame) {
    // frame->eax = EAX register value during interrupt
    // frame->int_no = interrupt vector number (0=division by zero, 3=breakpoint, etc.)
    // frame->err_code = error code (violation address for page fault)

    vga_set_color(VGA_LIGHT_RED, VGA_BLACK);
    vga_puts("[EXCEPTION] vec=");
    int n = frame->int_no;
    if (n >= 10) vga_putc('0' + (n/10));
    vga_putc('0' + (n%10));
    vga_puts(" err=");
    int e = frame->err_code;
    if (e >= 10) vga_putc('0' + (e/10));
    vga_putc('0' + (e%10));
    vga_puts("\n");
}
```

**Difference by presence/absence of error code:**

```
Exception without error code (uses ISR_NOERR):
E.g., Division by zero (#DE), Breakpoint (#BP)

Processing executed by ISR stub:
push dword 0     ; Push dummy error code
push dword %1    ; Vector number
jmp isr_common   ; To common processing

Exception with error code (uses ISR_ERR):
E.g., General protection fault (#GP), Page fault (#PF)

Processing executed by ISR stub:
                 ; CPU already pushed error code
push dword %1    ; Add only vector number
jmp isr_common   ; To common processing
```

### 4. IDT Registration and Operation Test

-   Register exception stubs to IDT like `set_idt_gate(0, (uint32_t)isr0);`
-   `load_idt();` for `lidt`
-   Test 1: Issue `int 0x03` (breakpoint) and confirm display
-   Test 2: Deliberately divide by zero and confirm `vec=0`

```c
extern void isr0(void);  // Defined in interrupt.s
extern void isr3(void);
extern void isr6(void);
extern void isr13(void);
extern void isr14(void);

void init_idt_and_exceptions(void) {
    for (int i=0;i<IDT_SIZE;i++) set_idt_gate(i, 0);
    set_idt_gate(0,  (uint32_t)isr0);
    set_idt_gate(3,  (uint32_t)isr3);
    set_idt_gate(6,  (uint32_t)isr6);
    set_idt_gate(13, (uint32_t)isr13);
    set_idt_gate(14, (uint32_t)isr14);
    load_idt();
}

void kmain(void) {
    vga_init();
    vga_puts("Day 05: IDT & Exceptions\n");
    init_idt_and_exceptions();

    __asm__ volatile ("int $0x03");  // Software interrupt
    // Division by zero test: uncomment line below
    // volatile int x=1, y=0; volatile int z = x / y;
}
```

### 5. Makefile (Example)

-   Like Day 03/04, build with boot split + C kernel configuration (including `interrupt.s`).
-   See `day05_complete/Makefile`.

## Troubleshooting

-   Black screen
    -   Check GDT/PE switch/far jump sequence (refer to Day 02/03)
    -   Check if `lidt` argument (`idtr`) `limit`/`base` are correct
-   Exception not displayed
    -   Check IDT entry `flags=0x8E` and `sel=0x08`
    -   Check if ISR stub symbol names match `set_idt_gate` registration numbers
-   Crash with `iret/iretd`
    -   Check if stack operations in `isr_common` (push order/addition amount) match
    -   Using `ISR_NOERR`/`ISR_ERR` properly based on error code presence/absence

## Understanding Check

1. Can you explain the meaning of each IDT entry field (base/sel/flags)?
2. Which exceptions automatically push error codes?
3. What's the difference between `int 0x03` and hardware interrupts (IRQ)?
4. How are the `limit` and `base` values passed to `lidt` determined?

## Next Steps

-   ✅ Basic IDT construction (exception handler registration)
-   ✅ ISR stub (assembly) and C handler cooperation
-   ✅ Software interrupt/exception visualization

Day 06 will introduce PIC/PIT to handle hardware interrupts (timer IRQ0, etc.) with PIC remapping, interrupt masking, and PIT configuration.